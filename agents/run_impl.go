// Copyright 2025 The NLP Odyssey Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package agents

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"slices"
	"sync"

	"github.com/nlpodyssey/openai-agents-go/asyncqueue"
	"github.com/nlpodyssey/openai-agents-go/computer"
	"github.com/nlpodyssey/openai-agents-go/modelsettings"
	"github.com/nlpodyssey/openai-agents-go/openaitypes"
	"github.com/nlpodyssey/openai-agents-go/tools"
	"github.com/openai/openai-go/packages/param"
	"github.com/openai/openai-go/responses"
	"github.com/openai/openai-go/shared/constant"
)

type queueCompleteSentinel struct{}

func (queueCompleteSentinel) isStreamEvent() {}

var notFinalOutput = ToolsToFinalOutputResult{
	IsFinalOutput: false,
	FinalOutput:   param.Null[any](),
}

type AgentToolUseTracker struct {
	AgentToTools []AgentToToolsItem
}

func NewAgentToolUseTracker() *AgentToolUseTracker {
	return &AgentToolUseTracker{}
}

type AgentToToolsItem struct {
	Agent     *Agent
	ToolNames []string
}

func (item *AgentToToolsItem) AppendToolNames(toolNames []string) {
	item.ToolNames = append(item.ToolNames, toolNames...)
}

func (t *AgentToolUseTracker) AddToolUse(agent *Agent, toolNames []string) {
	index := t.agentIndex(agent)
	if index == -1 {
		t.AgentToTools = append(t.AgentToTools, AgentToToolsItem{
			Agent:     agent,
			ToolNames: toolNames,
		})
	} else {
		t.AgentToTools[index].AppendToolNames(toolNames)
	}
}

func (t *AgentToolUseTracker) HasUsedTools(agent *Agent) bool {
	index := t.agentIndex(agent)
	return index != -1 && len(t.AgentToTools[index].ToolNames) > 0
}

func (t *AgentToolUseTracker) agentIndex(agent *Agent) int {
	return slices.IndexFunc(t.AgentToTools, func(item AgentToToolsItem) bool {
		return item.Agent == agent
	})
}

type ToolRunHandoff struct {
	Handoff  Handoff
	ToolCall ResponseFunctionToolCall
}

type ToolRunFunction struct {
	ToolCall     ResponseFunctionToolCall
	FunctionTool tools.Function
}

type ToolRunComputerAction struct {
	ToolCall     responses.ResponseComputerToolCall
	ComputerTool tools.ComputerTool
}

type ToolRunLocalShellCall struct {
	ToolCall       responses.ResponseOutputItemLocalShellCall
	LocalShellTool tools.LocalShell
}

type ProcessedResponse struct {
	NewItems        []RunItem
	Handoffs        []ToolRunHandoff
	Functions       []ToolRunFunction
	ComputerActions []ToolRunComputerAction
	LocalShellCalls []ToolRunLocalShellCall
	// Names of all tools used, including hosted tools
	ToolsUsed []string
}

func (pr *ProcessedResponse) HasToolsToRun() bool {
	// Handoffs, functions and computer actions need local processing.
	// Hosted tools have already run, so there's nothing to do.
	return len(pr.Handoffs) > 0 || len(pr.Functions) > 0 ||
		len(pr.ComputerActions) > 0 || len(pr.LocalShellCalls) > 0
}

type NextStep interface {
	isNextStep()
}

type NextStepHandoff struct {
	NewAgent *Agent
}

func (NextStepHandoff) isNextStep() {}

type NextStepFinalOutput struct {
	Output any
}

func (NextStepFinalOutput) isNextStep() {}

type NextStepRunAgain struct{}

func (NextStepRunAgain) isNextStep() {}

type SingleStepResult struct {
	// The input items i.e. the items before Run() was called. May be mutated by handoff input filters.
	OriginalInput Input

	// The model response for the current step.
	ModelResponse ModelResponse

	// Items generated before the current step.
	PreStepItems []RunItem

	// Items generated during this current step.
	NewStepItems []RunItem

	// The next step to take.
	NextStep NextStep
}

// GeneratedItems returns the items generated during the agent run (i.e. everything generated after `OriginalInput`).
func (result SingleStepResult) GeneratedItems() []RunItem {
	return slices.Concat(result.PreStepItems, result.NewStepItems)
}

type runImpl struct{}

func RunImpl() runImpl { return runImpl{} }

func (ri runImpl) ExecuteToolsAndSideEffects(
	ctx context.Context,
	agent *Agent,
	// The original input to the Runner
	originalInput Input,
	// Everything generated by Runner since the original input, but before the current step
	preStepItems []RunItem,
	newResponse ModelResponse,
	processedResponse ProcessedResponse,
	outputSchema AgentOutputSchemaInterface,
	hooks RunHooks,
	runConfig RunConfig,
) (*SingleStepResult, error) {
	// Make a copy of the generated items
	preStepItems = slices.Clone(preStepItems)

	var newStepItems []RunItem
	newStepItems = append(newStepItems, processedResponse.NewItems...)

	// First, let's run the tool calls - function tools and computer actions
	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()
	var (
		functionResults []FunctionToolResult
		computerResults []RunItem
		toolErrors      [2]error
		wg              sync.WaitGroup
	)
	wg.Add(2)
	go func() {
		defer wg.Done()
		functionResults, toolErrors[0] = ri.ExecuteFunctionToolCalls(
			childCtx,
			agent,
			processedResponse.Functions,
			hooks,
		)
	}()
	go func() {
		defer wg.Done()
		computerResults, toolErrors[1] = ri.ExecuteComputerActions(
			childCtx,
			agent,
			processedResponse.ComputerActions,
			hooks,
		)
	}()
	wg.Wait()
	if err := errors.Join(toolErrors[:]...); err != nil {
		return nil, err
	}

	for _, result := range functionResults {
		newStepItems = append(newStepItems, result.RunItem)
	}
	newStepItems = append(newStepItems, computerResults...)

	// Next, check if there are any handoffs
	if runHandoffs := processedResponse.Handoffs; len(runHandoffs) > 0 {
		return ri.ExecuteHandoffs(
			ctx,
			agent,
			originalInput,
			preStepItems,
			newStepItems,
			newResponse,
			runHandoffs,
			hooks,
			runConfig,
		)
	}

	// Next, we'll check if the tool use should result in a final output
	checkToolUse, err := ri.checkForFinalOutputFromTools(ctx, agent, functionResults)
	if err != nil {
		return nil, err
	}

	if checkToolUse.IsFinalOutput {
		if !checkToolUse.FinalOutput.Valid() {
			slog.Error("Model returned a final output of None. Not raising an error because we assume you know what you're doing.")
		}

		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			checkToolUse.FinalOutput.Or(nil),
			hooks,
		)
	}

	// Now we can check if the model also produced a final output
	messageItems := make([]MessageOutputItem, 0)
	for _, item := range newStepItems {
		if messageItem, ok := item.(MessageOutputItem); ok {
			messageItems = append(messageItems, messageItem)
		}
	}

	// We'll use the last content output as the final output
	potentialFinalOutputText := ""
	if len(messageItems) > 0 {
		rawItem := messageItems[len(messageItems)-1].RawItem
		potentialFinalOutputText, _ = ItemHelpers().ExtractLastText(
			openaitypes.ResponseOutputItemUnionFromResponseOutputMessage(rawItem))
	}

	// There are two possibilities that lead to a final output:
	// 1. Structured output schema => always leads to a final output
	// 2. Plain text output schema => only leads to a final output if there are no tool calls
	if outputSchema != nil && !outputSchema.IsPlainText() && potentialFinalOutputText != "" {
		finalOutput, err := outputSchema.ValidateJSON(potentialFinalOutputText)
		if err != nil {
			return nil, fmt.Errorf("final output schema validation failed: %w", err)
		}
		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			finalOutput,
			hooks,
		)
	} else if (outputSchema == nil || outputSchema.IsPlainText()) && !processedResponse.HasToolsToRun() {
		return ri.ExecuteFinalOutput(
			ctx,
			agent,
			originalInput,
			newResponse,
			preStepItems,
			newStepItems,
			potentialFinalOutputText,
			hooks,
		)
	} else {
		// If there's no final output, we can just run again
		return &SingleStepResult{
			OriginalInput: originalInput,
			ModelResponse: newResponse,
			PreStepItems:  preStepItems,
			NewStepItems:  newStepItems,
			NextStep:      NextStepRunAgain{},
		}, nil
	}
}

// MaybeResetToolChoice resets tool choice to None if the agent has used tools and the agent's reset_tool_choice
// flag is True.
func (runImpl) MaybeResetToolChoice(
	agent *Agent,
	toolUseTracker *AgentToolUseTracker,
	modelSettings modelsettings.ModelSettings,
) modelsettings.ModelSettings {
	resetToolChoice := agent.ResetToolChoice.Or(true)
	if resetToolChoice && toolUseTracker.HasUsedTools(agent) {
		newSettings := modelSettings
		newSettings.ToolChoice = ""
		return newSettings
	}
	return modelSettings
}

func (runImpl) ProcessModelResponse(
	agent *Agent,
	allTools []tools.Tool,
	response ModelResponse,
	handoffs []Handoff,
) (*ProcessedResponse, error) {
	var (
		items           []RunItem
		runHandoffs     []ToolRunHandoff
		functions       []ToolRunFunction
		computerActions []ToolRunComputerAction
		localShellCalls []ToolRunLocalShellCall
		computerTool    *tools.ComputerTool
		localShellTool  *tools.LocalShell
		toolsUsed       []string
	)

	handoffMap := make(map[string]Handoff, len(handoffs))
	for _, handoff := range handoffs {
		handoffMap[handoff.ToolName] = handoff
	}

	functionMap := make(map[string]tools.Function)

	for _, tool := range allTools {
		switch t := tool.(type) {
		case tools.Function:
			functionMap[t.Name] = t
		case tools.ComputerTool:
			computerTool = &t
		case tools.LocalShell:
			localShellTool = &t
		}
	}

	for _, outputUnion := range response.Output {
		switch outputUnion.Type {
		case "message":
			output := responses.ResponseOutputMessage{
				ID:      outputUnion.ID,
				Content: outputUnion.Content,
				Role:    outputUnion.Role,
				Status:  responses.ResponseOutputMessageStatus(outputUnion.Status),
				Type:    constant.ValueOf[constant.Message](),
			}
			items = append(items, MessageOutputItem{
				Agent:   agent,
				RawItem: output,
				Type:    "message_output_item",
			})
		case "file_search_call":
			output := responses.ResponseFileSearchToolCall{
				ID:      outputUnion.ID,
				Queries: outputUnion.Queries,
				Status:  responses.ResponseFileSearchToolCallStatus(outputUnion.Status),
				Type:    constant.ValueOf[constant.FileSearchCall](),
				Results: outputUnion.Results.OfResponseFileSearchToolCallResults,
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseFileSearchToolCall(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "file_search")
		case "web_search_call":
			output := responses.ResponseFunctionWebSearch{
				ID:     outputUnion.ID,
				Status: responses.ResponseFunctionWebSearchStatus(outputUnion.Status),
				Type:   constant.ValueOf[constant.WebSearchCall](),
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseFunctionWebSearch(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "web_search")
		case "reasoning":
			output := responses.ResponseReasoningItem{
				ID:               outputUnion.ID,
				Summary:          outputUnion.Summary,
				Type:             constant.ValueOf[constant.Reasoning](),
				EncryptedContent: outputUnion.EncryptedContent,
				Status:           responses.ResponseReasoningItemStatus(outputUnion.Status),
			}
			items = append(items, ReasoningItem{
				Agent:   agent,
				RawItem: output,
				Type:    "reasoning_item",
			})
		case "computer_call":
			output := responses.ResponseComputerToolCall{
				ID:                  outputUnion.ID,
				Action:              openaitypes.ResponseComputerToolCallActionUnionFromResponseOutputItemUnionAction(outputUnion.Action),
				CallID:              outputUnion.CallID,
				PendingSafetyChecks: outputUnion.PendingSafetyChecks,
				Status:              responses.ResponseComputerToolCallStatus(outputUnion.Status),
				Type:                responses.ResponseComputerToolCallTypeComputerCall,
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseComputerToolCall(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "computer_use")
			if computerTool == nil {
				return nil, NewModelBehaviorError("model produced computer action without a computer tool")
			}
			computerActions = append(computerActions, ToolRunComputerAction{
				ToolCall:     output,
				ComputerTool: *computerTool,
			})
		case "image_generation_call":
			output := responses.ResponseOutputItemImageGenerationCall{
				ID:     outputUnion.ID,
				Result: outputUnion.Result,
				Status: outputUnion.Status,
				Type:   constant.ValueOf[constant.ImageGenerationCall](),
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseOutputItemImageGenerationCall(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "image_generation")
		case "code_interpreter_call":
			output := responses.ResponseCodeInterpreterToolCall{
				ID:          outputUnion.ID,
				Code:        outputUnion.Code,
				Results:     outputUnion.Results.OfResponseCodeInterpreterToolCallResults,
				Status:      responses.ResponseCodeInterpreterToolCallStatus(outputUnion.Status),
				Type:        constant.ValueOf[constant.CodeInterpreterCall](),
				ContainerID: outputUnion.ContainerID,
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseCodeInterpreterToolCall(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "code_interpreter")
		case "local_shell_call":
			output := responses.ResponseOutputItemLocalShellCall{
				ID:     outputUnion.ID,
				Action: openaitypes.ResponseOutputItemLocalShellCallActionFromResponseOutputItemUnionAction(outputUnion.Action),
				CallID: outputUnion.CallID,
				Status: outputUnion.Status,
				Type:   constant.ValueOf[constant.LocalShellCall](),
			}
			items = append(items, ToolCallItem{
				Agent:   agent,
				RawItem: ResponseOutputItemLocalShellCall(output),
				Type:    "tool_call_item",
			})
			toolsUsed = append(toolsUsed, "local_shell")
			if localShellTool == nil {
				return nil, NewModelBehaviorError("model produced local shell call without a local shell tool")
			}
			localShellCalls = append(localShellCalls, ToolRunLocalShellCall{
				ToolCall:       output,
				LocalShellTool: *localShellTool,
			})
		case "function_call":
			output := responses.ResponseFunctionToolCall{
				Arguments: outputUnion.Arguments,
				CallID:    outputUnion.CallID,
				Name:      outputUnion.Name,
				Type:      constant.ValueOf[constant.FunctionCall](),
				ID:        outputUnion.ID,
				Status:    responses.ResponseFunctionToolCallStatus(outputUnion.Status),
			}

			toolsUsed = append(toolsUsed, output.Name)

			// Handoffs
			if handoff, ok := handoffMap[output.Name]; ok {
				items = append(items, HandoffCallItem{
					Agent:   agent,
					RawItem: output,
					Type:    "handoff_call_item",
				})
				runHandoffs = append(runHandoffs, ToolRunHandoff{
					Handoff:  handoff,
					ToolCall: ResponseFunctionToolCall(output),
				})
			} else { // Regular function tool call
				functionTool, ok := functionMap[output.Name]
				if !ok {
					return nil, ModelBehaviorErrorf("Tool %s not found in agent %s", output.Name, agent.Name)
				}
				items = append(items, ToolCallItem{
					Agent:   agent,
					RawItem: ResponseFunctionToolCall(output),
					Type:    "tool_call_item",
				})
				functions = append(functions, ToolRunFunction{
					ToolCall:     ResponseFunctionToolCall(output),
					FunctionTool: functionTool,
				})
			}
		default:
			slog.Warn(fmt.Sprintf("unexpected output type, ignoring %q", outputUnion.Type))
		}
	}

	return &ProcessedResponse{
		NewItems:        items,
		Handoffs:        runHandoffs,
		Functions:       functions,
		ComputerActions: computerActions,
		LocalShellCalls: localShellCalls,
		ToolsUsed:       toolsUsed,
	}, nil
}

type FunctionToolResult struct {
	// The tool that was run.
	Tool tools.Function

	// The output of the tool.
	Output any

	// The run item that was produced as a result of the tool call.
	RunItem RunItem
}

func (runImpl) ExecuteFunctionToolCalls(
	ctx context.Context,
	agent *Agent,
	toolRuns []ToolRunFunction,
	hooks RunHooks,
) ([]FunctionToolResult, error) {
	runSingleTool := func(
		ctx context.Context,
		funcTool tools.Function,
		toolCall ResponseFunctionToolCall,
	) (any, error) {
		var (
			hooksErrors [2]error
			toolError   error
			result      any
		)

		childCtx, cancel := context.WithCancel(ctx)
		defer cancel()

		var wg sync.WaitGroup

		wg.Add(1)
		go func() {
			defer wg.Done()
			err := hooks.OnToolStart(childCtx, agent, funcTool)
			if err != nil {
				cancel()
				hooksErrors[0] = fmt.Errorf("RunHooks.OnToolStart failed: %w", err)
			}
		}()

		if agent.Hooks != nil {
			wg.Add(1)
			go func() {
				defer wg.Done()
				err := agent.Hooks.OnToolStart(childCtx, agent, funcTool)
				if err != nil {
					cancel()
					hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolStart failed: %w", err)
				}
			}()
		}

		wg.Add(1)
		go func() {
			defer wg.Done()
			result, toolError = funcTool.OnInvokeTool(childCtx, toolCall.Arguments)
			if toolError != nil {
				cancel()
			}
		}()

		wg.Wait()

		if err := errors.Join(hooksErrors[:]...); err != nil {
			return nil, err
		}
		if toolError != nil {
			return nil, fmt.Errorf("error running tool %s: %w", funcTool.Name, toolError)
		}

		wg.Add(1)
		go func() {
			defer wg.Done()
			err := hooks.OnToolEnd(childCtx, agent, funcTool, result)
			if err != nil {
				cancel()
				hooksErrors[0] = fmt.Errorf("RunHooks.OnToolEnd failed: %w", err)
			}
		}()

		if agent.Hooks != nil {
			wg.Add(1)
			go func() {
				defer wg.Done()
				err := agent.Hooks.OnToolEnd(childCtx, agent, funcTool, result)
				if err != nil {
					cancel()
					hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolEnd failed: %w", err)
				}
			}()
		}

		wg.Wait()
		if err := errors.Join(hooksErrors[:]...); err != nil {
			return nil, err
		}
		return result, nil
	}

	results := make([]any, len(toolRuns))
	resultErrors := make([]error, len(toolRuns))

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup
	wg.Add(len(toolRuns))

	for i, toolRun := range toolRuns {
		go func() {
			defer wg.Done()
			results[i], resultErrors[i] = runSingleTool(childCtx, toolRun.FunctionTool, toolRun.ToolCall)
			if resultErrors[i] != nil {
				cancel()
			}
		}()
	}

	wg.Wait()
	if err := errors.Join(resultErrors...); err != nil {
		return nil, err
	}

	functionToolResults := make([]FunctionToolResult, len(results))
	for i, result := range results {
		toolRun := toolRuns[i]

		var strResult string
		switch v := result.(type) {
		case string:
			strResult = v
		case []byte:
			strResult = string(v)
		default:
			out, err := json.Marshal(v)
			if err != nil {
				return nil, err
			}
			strResult = string(out)
		}

		functionToolResults[i] = FunctionToolResult{
			Tool:   toolRun.FunctionTool,
			Output: result,
			RunItem: ToolCallOutputItem{
				Agent: agent,
				RawItem: ResponseInputItemFunctionCallOutputParam(
					ItemHelpers().ToolCallOutputItem(toolRun.ToolCall, strResult)),
				Output: result,
				Type:   "tool_call_output_item",
			},
		}
	}

	return functionToolResults, nil
}

func (runImpl) ExecuteLocalShellCalls(
	ctx context.Context,
	agent *Agent,
	calls []ToolRunLocalShellCall,
	hooks RunHooks,
) ([]RunItem, error) {
	results := make([]RunItem, len(calls))

	// Need to run these serially, because each call can affect the local shell state
	for i, call := range calls {
		result, err := LocalShellAction().Execute(ctx, agent, call, hooks)
		if err != nil {
			return nil, err
		}
		results[i] = result
	}

	return results, nil
}

func (runImpl) ExecuteComputerActions(
	ctx context.Context,
	agent *Agent,
	actions []ToolRunComputerAction,
	hooks RunHooks,
) ([]RunItem, error) {
	results := make([]RunItem, len(actions))

	// Need to run these serially, because each action can affect the computer state
	for i, action := range actions {
		result, err := ComputerAction().Execute(ctx, agent, action, hooks)
		if err != nil {
			return nil, err
		}
		results[i] = result
	}

	return results, nil
}

func (runImpl) ExecuteHandoffs(
	ctx context.Context,
	agent *Agent,
	originalInput Input,
	preStepItems []RunItem,
	newStepItems []RunItem,
	newResponse ModelResponse,
	runHandoffs []ToolRunHandoff,
	hooks RunHooks,
	runConfig RunConfig,
) (*SingleStepResult, error) {
	// If there is more than one handoff, add tool responses that reject those handoffs
	multipleHandoffs := len(runHandoffs) > 1

	if multipleHandoffs {
		const outputMessage = "Multiple handoffs detected, ignoring this one."
		for _, handoff := range runHandoffs[1:] {
			newStepItems = append(newStepItems, ToolCallOutputItem{
				Agent: agent,
				RawItem: ResponseInputItemFunctionCallOutputParam(
					ItemHelpers().ToolCallOutputItem(handoff.ToolCall, outputMessage)),
				Output: outputMessage,
				Type:   "tool_call_output_item",
			})
		}
	}

	actualHandoff := runHandoffs[0]
	handoff := actualHandoff.Handoff
	newAgent, err := handoff.OnInvokeHandoff(ctx, actualHandoff.ToolCall.Arguments)
	if err != nil {
		return nil, fmt.Errorf("failed to invoke handoff: %w", err)
	}

	// Append a tool output item for the handoff
	toolCallOutputItem := ItemHelpers().ToolCallOutputItem(
		actualHandoff.ToolCall,
		handoff.GetTransferMessage(newAgent),
	)
	newStepItems = append(newStepItems, HandoffOutputItem{
		Agent: agent,
		RawItem: TResponseInputItem{
			OfFunctionCallOutput: &toolCallOutputItem,
		},
		SourceAgent: agent,
		TargetAgent: newAgent,
		Type:        "handoff_output_item",
	})

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Execute handoff hooks
	var wg sync.WaitGroup
	var handoffErrors [2]error

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnHandoff(childCtx, agent, newAgent)
		if err != nil {
			cancel()
			handoffErrors[0] = fmt.Errorf("RunHooks.OnHandoff failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnHandoff(childCtx, newAgent, agent)
			if err != nil {
				cancel()
				handoffErrors[0] = fmt.Errorf("AgentHooks.OnHandoff failed: %w", err)
			}
		}()
	}

	wg.Wait()
	if err = errors.Join(handoffErrors[:]...); err != nil {
		return nil, err
	}

	// If there's an input filter, filter the input for the next agent
	inputFilter := handoff.InputFilter
	if inputFilter == nil {
		inputFilter = runConfig.HandoffInputFilter
	}
	if inputFilter != nil {
		slog.Debug("Filtering inputs for handoff")
		handoffInputData := HandoffInputData{
			InputHistory:    CopyGeneralInput(originalInput),
			PreHandoffItems: slices.Clone(preStepItems),
			NewItems:        slices.Clone(newStepItems),
		}
		filtered, err := inputFilter(ctx, handoffInputData)
		if err != nil {
			return nil, fmt.Errorf("handoff input filter error: %w", err)
		}

		originalInput = CopyGeneralInput(filtered.InputHistory)
		preStepItems = slices.Clone(filtered.PreHandoffItems)
		newStepItems = slices.Clone(filtered.NewItems)
	}

	return &SingleStepResult{
		OriginalInput: originalInput,
		ModelResponse: newResponse,
		PreStepItems:  preStepItems,
		NewStepItems:  newStepItems,
		NextStep:      NextStepHandoff{NewAgent: newAgent},
	}, nil
}

func (ri runImpl) ExecuteFinalOutput(
	ctx context.Context,
	agent *Agent,
	originalInput Input,
	newResponse ModelResponse,
	preStepItems []RunItem,
	newStepItems []RunItem,
	finalOutput any,
	hooks RunHooks,
) (*SingleStepResult, error) {
	// Run the onEnd hooks
	err := ri.RunFinalOutputHooks(ctx, agent, hooks, finalOutput)
	if err != nil {
		return nil, err
	}

	return &SingleStepResult{
		OriginalInput: originalInput,
		ModelResponse: newResponse,
		PreStepItems:  preStepItems,
		NewStepItems:  newStepItems,
		NextStep:      NextStepFinalOutput{Output: finalOutput},
	}, nil
}

func (ri runImpl) RunFinalOutputHooks(
	ctx context.Context,
	agent *Agent,
	hooks RunHooks,
	finalOutput any,
) error {
	var hooksErrors [2]error

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnAgentEnd(childCtx, agent, finalOutput)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnAgentEnd failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnEnd(childCtx, agent, finalOutput)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnEnd failed: %w", err)
			}
		}()
	}

	wg.Wait()
	return errors.Join(hooksErrors[:]...)
}

func (runImpl) RunSingleInputGuardrail(
	ctx context.Context,
	agent *Agent,
	guardrail InputGuardrail,
	input Input,
) (InputGuardrailResult, error) {
	return guardrail.Run(ctx, agent, input)
}

func (runImpl) RunSingleOutputGuardrail(
	ctx context.Context,
	guardrail OutputGuardrail,
	agent *Agent,
	agentOutput any,
) (OutputGuardrailResult, error) {
	return guardrail.Run(ctx, agent, agentOutput)
}

func (runImpl) StreamStepResultToQueue(stepResult SingleStepResult, queue *asyncqueue.Queue[StreamEvent]) {
	for _, item := range stepResult.NewStepItems {
		var event StreamEvent

		switch item.(type) {
		case MessageOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventMessageOutputCreated,
				Item: item,
				Type: "run_item_stream_event",
			}
		case HandoffCallItem:
			event = RunItemStreamEvent{
				Name: StreamEventHandoffRequested,
				Item: item,
				Type: "run_item_stream_event",
			}
		case HandoffOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventHandoffOccurred,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ToolCallItem:
			event = RunItemStreamEvent{
				Name: StreamEventToolCalled,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ToolCallOutputItem:
			event = RunItemStreamEvent{
				Name: StreamEventToolOutput,
				Item: item,
				Type: "run_item_stream_event",
			}
		case ReasoningItem:
			event = RunItemStreamEvent{
				Name: StreamEventReasoningItemCreated,
				Item: item,
				Type: "run_item_stream_event",
			}
		default:
			// This would be an unrecoverable implementation bug, so a panic is appropriate.
			panic(fmt.Errorf("unexpected RunItem type %T", item))
		}

		queue.Put(event)
	}
}

// Returns (i, final_output).
func (runImpl) checkForFinalOutputFromTools(
	ctx context.Context,
	agent *Agent,
	toolResults []FunctionToolResult,
) (ToolsToFinalOutputResult, error) {
	if len(toolResults) == 0 {
		return notFinalOutput, nil
	}

	toolUseBehavior := agent.ToolUseBehavior
	if toolUseBehavior == nil {
		toolUseBehavior = RunLLMAgain{}
	}

	switch v := toolUseBehavior.(type) {
	case RunLLMAgain:
		return notFinalOutput, nil
	case StopOnFirstTool:
		return ToolsToFinalOutputResult{
			IsFinalOutput: true,
			FinalOutput:   param.NewOpt(toolResults[0].Output),
		}, nil
	case StopAtTools:
		for _, toolResult := range toolResults {
			if slices.Contains(v.StopAtToolNames, toolResult.Tool.Name) {
				return ToolsToFinalOutputResult{
					IsFinalOutput: true,
					FinalOutput:   param.NewOpt(toolResult.Output),
				}, nil
			}
		}
		return notFinalOutput, nil
	case ToolsToFinalOutputFunction:
		return v(ctx, toolResults)
	default:
		// This would be an unrecoverable implementation bug, so a panic is appropriate.
		panic(fmt.Errorf("unexpected ToolUseBehavior type %T", v))
	}
}

type computerAction struct{}

func ComputerAction() computerAction { return computerAction{} }

func (ca computerAction) Execute(
	ctx context.Context,
	agent *Agent,
	action ToolRunComputerAction,
	hooks RunHooks,
) (RunItem, error) {
	var (
		hooksErrors [2]error
		toolError   error
		output      string
	)

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnToolStart(childCtx, agent, action.ComputerTool)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnToolStart failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnToolStart(childCtx, agent, action.ComputerTool)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolStart failed: %w", err)
			}
		}()
	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		output, toolError = ca.getScreenshot(ctx, action.ComputerTool.Computer, action.ToolCall)
		if toolError != nil {
			cancel()
		}
	}()

	wg.Wait()

	if err := errors.Join(hooksErrors[:]...); err != nil {
		return nil, err
	}
	if toolError != nil {
		return nil, fmt.Errorf("error running computer tool: %w", toolError)
	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnToolEnd(childCtx, agent, action.ComputerTool, output)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnToolEnd failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnToolEnd(childCtx, agent, action.ComputerTool, output)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolEnd failed: %w", err)
			}
		}()
	}

	wg.Wait()
	if err := errors.Join(hooksErrors[:]...); err != nil {
		return nil, err
	}

	// TODO: don't send a screenshot every single time, use references
	imageURL := "data:image/png;base64," + output
	return ToolCallOutputItem{
		Agent: agent,
		RawItem: ResponseInputItemComputerCallOutputParam{
			CallID: action.ToolCall.CallID,
			Output: responses.ResponseComputerToolCallOutputScreenshotParam{
				ImageURL: param.NewOpt(imageURL),
				Type:     constant.ValueOf[constant.ComputerScreenshot](),
			},
			Type: constant.ValueOf[constant.ComputerCallOutput](),
		},
		Output: imageURL,
		Type:   "tool_call_output_item",
	}, nil
}

func (computerAction) getScreenshot(
	ctx context.Context,
	comp computer.Computer,
	toolCall responses.ResponseComputerToolCall,
) (string, error) {
	action := toolCall.Action

	var err error
	switch action.Type {
	case "click":
		err = comp.Click(ctx, action.X, action.Y, computer.Button(action.Button))
	case "double_click":
		err = comp.DoubleClick(ctx, action.X, action.Y)
	case "drag":
		path := make([]computer.Position, len(action.Path))
		for i, p := range action.Path {
			path[i] = computer.Position{X: p.X, Y: p.Y}
		}
		err = comp.Drag(ctx, path)
	case "keypress":
		err = comp.Keypress(ctx, action.Keys)
	case "move":
		err = comp.Move(ctx, action.X, action.Y)
	case "screenshot":
		_, err = comp.Screenshot(ctx)
	case "scroll":
		err = comp.Scroll(ctx, action.X, action.Y, action.ScrollX, action.ScrollY)
	case "type":
		err = comp.Type(ctx, action.Text)
	case "wait":
		err = comp.Wait(ctx)
	default:
		err = fmt.Errorf("unexpected ResponseComputerToolCallActionUnion type %q", action.Type)
	}
	if err != nil {
		return "", err
	}

	return comp.Screenshot(ctx)
}

type localShellAction struct{}

func LocalShellAction() localShellAction { return localShellAction{} }

func (localShellAction) Execute(
	ctx context.Context,
	agent *Agent,
	call ToolRunLocalShellCall,
	hooks RunHooks,
) (RunItem, error) {
	var hooksErrors [2]error

	childCtx, cancel := context.WithCancel(ctx)
	defer cancel()

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnToolStart(childCtx, agent, call.LocalShellTool)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnToolStart failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnToolStart(childCtx, agent, call.LocalShellTool)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolStart failed: %w", err)
			}
		}()
	}

	wg.Wait()
	if err := errors.Join(hooksErrors[:]...); err != nil {
		return nil, err
	}

	// TODO: why this does not run concurrently with the hooks, as for other tools?
	request := tools.LocalShellCommandRequest{Data: call.ToolCall}
	result, err := call.LocalShellTool.Executor(ctx, request)
	if err != nil {
		return nil, err
	}

	wg.Add(1)
	go func() {
		defer wg.Done()
		err := hooks.OnToolEnd(childCtx, agent, call.LocalShellTool, result)
		if err != nil {
			cancel()
			hooksErrors[0] = fmt.Errorf("RunHooks.OnToolEnd failed: %w", err)
		}
	}()

	if agent.Hooks != nil {
		wg.Add(1)
		go func() {
			defer wg.Done()
			err := agent.Hooks.OnToolEnd(childCtx, agent, call.LocalShellTool, result)
			if err != nil {
				cancel()
				hooksErrors[1] = fmt.Errorf("AgentHooks.OnToolEnd failed: %w", err)
			}
		}()
	}

	wg.Wait()
	if err = errors.Join(hooksErrors[:]...); err != nil {
		return nil, err
	}

	return ToolCallOutputItem{
		Agent: agent,
		RawItem: ResponseInputItemLocalShellCallOutputParam{
			ID:     call.ToolCall.CallID,
			Output: result,
			Status: "",
			Type:   constant.ValueOf[constant.LocalShellCallOutput](),
		},
		Output: result,
		Type:   "tool_call_output_item",
	}, nil
}
