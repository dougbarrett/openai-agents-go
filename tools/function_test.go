package tools_test

import (
	"context"
	"encoding/json"
	"testing"

	. "github.com/nlpodyssey/openai-agents-go/tools"
	"github.com/openai/openai-go/packages/param"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

type Weather struct {
	City             string `json:"city"`
	TemperatureRange string `json:"temperature_range"`
	Conditions       string `json:"conditions"`
}

type GetWeatherArgs struct {
	City string `json:"city"`
}

func GetWeather(_ context.Context, args GetWeatherArgs) (Weather, error) {
	return Weather{
		City:             args.City,
		TemperatureRange: "14-20C",
		Conditions:       "Sunny with wind.",
	}, nil
}

func TestGetWeatherTool_Manual(t *testing.T) {
	GetWeatherTool := Function{
		Name:        "get_weather",
		Description: "",
		ParamsJSONSchema: map[string]any{
			"type":                 "object",
			"required":             []string{"city"},
			"additionalProperties": false,
			"properties": map[string]any{
				"city": map[string]any{
					"type": "string",
				},
			},
		},
		OnInvokeTool: func(ctx context.Context, arguments string) (any, error) {
			var args GetWeatherArgs
			err := json.Unmarshal([]byte(arguments), &args)
			if err != nil {
				return nil, err
			}
			return GetWeather(ctx, args)
		},
		StrictJSONSchema: param.NewOpt(true),
	}

	t.Run("ManualTool_BasicProperties", func(t *testing.T) {
		assert.Equal(t, "get_weather", GetWeatherTool.ToolName())
		assert.Equal(t, "", GetWeatherTool.Description)
		assert.True(t, GetWeatherTool.StrictJSONSchema.Value)
	})

	t.Run("ManualTool_Schema", func(t *testing.T) {
		schema := GetWeatherTool.ParamsJSONSchema

		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])
		assert.Equal(t, []string{"city"}, schema["required"])

		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)

		cityProp, ok := properties["city"].(map[string]any)
		require.True(t, ok)
		assert.Equal(t, "string", cityProp["type"])
	})

	t.Run("ManualTool_Invocation", func(t *testing.T) {
		args := `{"city": "Tokyo"}`
		result, err := GetWeatherTool.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)
		weather, ok := result.(Weather)
		require.True(t, ok)

		assert.Equal(t, "Tokyo", weather.City)
		assert.Equal(t, "14-20C", weather.TemperatureRange)
		assert.Equal(t, "Sunny with wind.", weather.Conditions)
	})
}

func TestGetWeatherTool_NewFunctionTool(t *testing.T) {
	GetWeatherToolNew := NewFunctionTool("get_weather", "", GetWeather)

	t.Run("AutoTool_BasicProperties", func(t *testing.T) {
		assert.Equal(t, "get_weather", GetWeatherToolNew.ToolName())
		assert.Equal(t, "", GetWeatherToolNew.Description) // Empty description
		assert.True(t, GetWeatherToolNew.StrictJSONSchema.Value)
	})

	t.Run("AutoTool_GeneratedSchema", func(t *testing.T) {
		schema := GetWeatherToolNew.ParamsJSONSchema

		// Auto-generated schema structure
		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])

		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)

		cityProp, ok := properties["city"].(map[string]any)
		require.True(t, ok)
		assert.Equal(t, "string", cityProp["type"])

		// Check required fields
		required, ok := schema["required"].([]any)
		require.True(t, ok)
		// Convert to string slice for easier assertion
		var requiredStrings []string
		for _, r := range required {
			requiredStrings = append(requiredStrings, r.(string))
		}
		assert.Contains(t, requiredStrings, "city")
	})

	t.Run("AutoTool_Invocation", func(t *testing.T) {
		args := `{"city": "Tokyo"}`
		result, err := GetWeatherToolNew.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)

		// Result should be a Weather
		_, ok := result.(Weather)
		require.True(t, ok)
	})
}

func TestManualVsAutoGenerated_SchemaDifferences(t *testing.T) {
	// Create both tools for comparison
	manualTool := Function{
		Name:        "get_weather",
		Description: "",
		ParamsJSONSchema: map[string]any{
			"type":                 "object",
			"required":             []string{"city"},
			"additionalProperties": false,
			"properties": map[string]any{
				"city": map[string]any{
					"type": "string",
				},
			},
		},
		OnInvokeTool: func(ctx context.Context, arguments string) (any, error) {
			var args GetWeatherArgs
			err := json.Unmarshal([]byte(arguments), &args)
			if err != nil {
				return nil, err
			}
			return GetWeather(ctx, args)
		},
		StrictJSONSchema: param.NewOpt(true),
	}

	autoTool := NewFunctionTool("get_weather", "", GetWeather)

	t.Run("SchemaDifferences", func(t *testing.T) {
		manualSchema := manualTool.ParamsJSONSchema
		autoSchema := autoTool.ParamsJSONSchema

		// Both should have the same basic structure
		assert.Equal(t, "object", manualSchema["type"])
		assert.Equal(t, "object", autoSchema["type"])
		assert.Equal(t, false, manualSchema["additionalProperties"])
		assert.Equal(t, false, autoSchema["additionalProperties"])

		manualProps := manualSchema["properties"].(map[string]any)
		autoProps := autoSchema["properties"].(map[string]any)

		manualCity := manualProps["city"].(map[string]any)
		autoCity := autoProps["city"].(map[string]any)

		// Both should have same type
		assert.Equal(t, "string", manualCity["type"])
		assert.Equal(t, "string", autoCity["type"])
	})

	t.Run("FunctionalEquivalence", func(t *testing.T) {
		// Both tools should produce the same results when invoked
		args := `{"city": "Paris"}`

		manualWeather, err1 := manualTool.OnInvokeTool(t.Context(), args)
		autoWeather, err2 := autoTool.OnInvokeTool(t.Context(), args)

		require.NoError(t, err1)
		require.NoError(t, err2)

		assert.Equal(t, manualWeather, autoWeather)
	})
}

func TestFunction_ErrorHandling(t *testing.T) {
	tool := NewFunctionTool("test_tool", "Test tool", GetWeather)

	t.Run("InvalidJSON", func(t *testing.T) {
		// Invalid JSON should return error
		args := `{"city": "Tokyo"`
		_, err := tool.OnInvokeTool(t.Context(), args)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "failed to parse arguments")
	})

	t.Run("MissingRequiredField", func(t *testing.T) {
		// Missing city field should still work (JSON unmarshaling will use zero value)
		args := `{}`
		result, err := tool.OnInvokeTool(t.Context(), args)
		require.NoError(t, err)

		// Result should be a Weather
		weather, ok := result.(Weather)
		require.True(t, ok)

		// City should be empty string (zero value)
		assert.Equal(t, "", weather.City)
	})
}

func TestNewFunctionTool_EmptyStructArgs(t *testing.T) {
	type emptyStruct struct{}
	handler := func(ctx context.Context, args emptyStruct) (string, error) {
		return "ok", nil
	}

	tool := NewFunctionTool("empty_tool", "", handler)

	t.Run("Schema", func(t *testing.T) {
		schema := tool.ParamsJSONSchema
		assert.Equal(t, "object", schema["type"])
		assert.Equal(t, false, schema["additionalProperties"])
		properties, ok := schema["properties"].(map[string]any)
		require.True(t, ok)
		assert.Len(t, properties, 0)
		_, hasRequired := schema["required"]
		assert.False(t, hasRequired)
	})

	t.Run("Invocation", func(t *testing.T) {
		result, err := tool.OnInvokeTool(t.Context(), `{}`)
		require.NoError(t, err)
		assert.Equal(t, "ok", result.(string))
	})
}
